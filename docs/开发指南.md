# 开发指南

**版本**: 1.0.0
**最后更新**: 2026-02-01

---

## 目录

- [环境准备](#环境准备)
- [构建项目](#构建项目)
- [开发工作流](#开发工作流)
- [代码规范](#代码规范)
- [测试指南](#测试指南)
- [调试技巧](#调试技巧)
- [贡献流程](#贡献流程)
- [常见问题](#常见问题)

---

## 环境准备

### 系统要求

| 组件 | 最低要求 | 推荐配置 |
|------|---------|---------|
| **操作系统** | Linux 5.4+ / macOS | Ubuntu 22.04+ |
| **内存** | 4GB | 8GB+ |
| **磁盘** | 10GB 可用空间 | SSD 50GB+ |
| **CPU** | 2核 | 4核+ |

### 安装依赖

#### 1. 安装 Rust

```bash
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
source $HOME/.cargo/env

# 验证安装
rustc --version  # 应显示 1.70+ (Edition 2021)
cargo --version
```

#### 2. 安装 protoc (Protocol Buffers 编译器)

**Ubuntu/Debian:**
```bash
sudo apt update
sudo apt install -y protobuf-compiler
protoc --version  # 应显示 3.x+
```

**macOS:**
```bash
brew install protobuf
```

**Windows:**
```bash
choco install protoc
```

#### 3. 安装开发工具

```bash
# 使用项目 Makefile 中的 setup 命令
make setup

# 或手动安装工具
cargo install cargo-watch      # 文件监控自动重新编译
cargo install cargo-expand     # 宏展开查看
cargo install cargo-tree       # 依赖树分析
cargo install cargo-audit      # 安全审计
```

### IDE 配置

#### VSCode

推荐安装以下扩展：

```json
{
  "recommendations": [
    "rust-lang.rust-analyzer",
    "tamasfe.even-better-toml",
    "serayuzgur.crates",
    "usernamehw.errorlens",
    "vadimcn.vscode-lldb"
  ]
}
```

配置 `.vscode/settings.json`:

```json
{
  "rust-analyzer.cargo.features": "all",
  "rust-analyzer.checkOnSave.command": "clippy",
  "rust-analyzer.cargo.loadOutDirsFromCheck": true,
  "files.watcherExclude": {
    "**/target/**": true,
    "**/node_modules/**": true
  }
}
```

#### IntelliJ IDEA

安装 Rust 插件，配置：
- Rust toolchain: 使用系统 Rust 安装
- Cargo: 使用项目 workspace
- External Linter: Clippy

---

## 构建项目

### 开发构建

```bash
# 完整开发构建
make dev

# 等同于:
cargo fmt --all
cargo clippy --workspace --all-targets --all-features -- -D warnings
cargo test --workspace
```

### 发布构建

```bash
# 优化构建
make build

# 或直接使用 Cargo
cargo build --release

# 构建特定 binary
cargo build -p norn --release
```

### 构建选项

```bash
# 只编译不运行测试
cargo check

# 编译特定 crate
cargo check -p norn-core

# 编译特定目标
cargo check --bin norn
cargo check --lib

# 启用所有特性
cargo build --all-features

# 带调试符号
cargo build --profile dev
```

---

## 开发工作流

### 1. 分支策略

```bash
main           # 主分支，始终保持稳定
├── develop    # 开发分支，集成最新功能
│   ├── feature/*  # 功能分支
│   ├── fix/*       # 修复分支
│   └── refactor/*  # 重构分支
```

### 2. 开始新功能

```bash
# 从 main 创建功能分支
git checkout main
git pull origin main
git checkout -b feature/your-feature-name

# 开始开发...
```

### 3. 提交更改

```bash
# 查看变更
git status

# 暂存文件
git add path/to/file.rs
# 或暂存所有
git add .

# 提交（遵循约定式提交）
git commit -m "feat: add transaction pool priority queue"

# 提交类型:
# feat: 新功能
# fix: 修复 bug
# docs: 文档更新
# style: 代码格式（不影响功能）
# refactor: 重构
# test: 添加测试
# chore: 构建/工具变更
```

### 4. 推送和 PR

```bash
# 推送分支
git push origin feature/your-feature-name

# 在 GitHub 创建 Pull Request
# 标题格式: [类型] 简短描述
# 例如: [Feature] Add transaction pool priority queue
```

### 5. 代码审查清单

- [ ] 代码符合 Rust 风格指南
- [ ] 所有测试通过 (`cargo test`)
- [ ] Clippy 无警告 (`cargo clippy`)
- [ ] 文档完整（pub 函数有注释）
- [ ] 添加了必要的集成测试
- [ ] 更新了相关文档

---

## 代码规范

### Rust 命名规范

```rust
// Crate: 小写，下划线
mod norn_core;

// Module: 小写，下划线
mod tx_pool;

// Struct/Enum: 大驼峰
pub struct BlockHeader {}
pub enum TransactionType {}

// Function/Variable: 小写，下划线
pub fn get_block_by_hash() {}
let block_count = 10;

// Constant: 全大写，下划线
pub const MAX_GAS_LIMIT: u64 = 30_000_000;

// Type Parameter: 简短大驼峰
pub struct Cache<K, V> {}
```

### 注释规范

```rust
/// 区块链结构体
///
/// 维护完整的区块链状态，包括：
/// - 最新区块
/// - 区块索引
/// - 状态根
///
/// # 示例
///
/// ```
/// let blockchain = Blockchain::new(config);
/// blockchain.add_block(block).await;
/// ```
///
/// # 错误
///
/// 如果区块验证失败，返回 `BlockError::ValidationFailed`
pub struct Blockchain {
    // ...
}

// 单行注释解释复杂逻辑
// 使用 VRF 随机选择领导者，但需要等待 VDF 完成以防止提前知道结果
let leader = self.select_leader().await?;
```

### 错误处理规范

```rust
// 使用 thiserror 定义错误类型
#[derive(Debug, thiserror::Error)]
pub enum BlockError {
    #[error("Invalid block header: {0}")]
    InvalidHeader(String),

    #[error("State root mismatch")]
    StateRootMismatch,

    #[error("Verification failed: {0}")]
    VerificationFailed(String),
}

// 使用 anyhow 进行错误传播
pub async fn process_block(&self, block: Block) -> Result<()> {
    self.validate_header(&block.header)?;
    self.execute_transactions(&block.transactions)?;
    self.update_state()?;
    Ok(())
}
```

### 异步代码规范

```rust
// 使用 Arc + RwLock 共享状态
pub struct Blockchain {
    latest_block: Arc<RwLock<Block>>,
}

// async 函数命名
pub async fn get_block(&self) -> Block {
    self.latest_block.read().await.clone()
}

// 避免阻塞异步代码
// ❌ 错误: 在 async 中使用阻塞调用
pub async fn bad_example() {
    std::thread::sleep(std::time::Duration::from_secs(1));
}

// ✅ 正确: 使用 Tokio 时间工具
pub async fn good_example() {
    tokio::time::sleep(Duration::from_secs(1)).await;
}
```

---

## 测试指南

### 单元测试

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_block_validation() {
        let blockchain = Blockchain::new(test_config());
        let block = create_test_block();

        let result = blockchain.validate_block(&block).await;
        assert!(result.is_ok());
    }

    #[test]
    fn test_merkle_root() {
        let txs = vec![create_test_tx(), create_test_tx()];
        let root = calculate_merkle_root(&txs);
        assert_ne!(root, Hash::default());
    }
}
```

### 集成测试

在 `test_integration/` 目录创建测试文件：

```rust
// test_integration/blockchain_test.rs
#[tokio::test]
async fn test_full_block_flow() {
    // 1. 启动测试节点
    let node = start_test_node().await;

    // 2. 发送交易
    let tx = create_test_transaction();
    node.send_transaction(tx).await;

    // 3. 等待区块
    tokio::time::sleep(Duration::from_secs(2)).await;

    // 4. 验证状态
    let block = node.get_latest_block().await;
    assert_eq!(block.transactions.len(), 1);
}
```

### 运行测试

```bash
# 所有测试
make test

# 或使用 cargo
cargo test --workspace

# 特定 crate 测试
cargo test -p norn-core

# 特定测试函数
cargo test test_block_validation

# 显示测试输出
cargo test -- --nocapture

# 运行忽略的测试
cargo test -- --ignored

# 并行测试（默认）
cargo test -- --test-threads=4

# 串行测试
cargo test -- --test-threads=1
```

### 基准测试

```rust
// 在 benches/ 目录下
use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn benchmark_merkle(c: &mut Criterion) {
    let txs = create_test_transactions(1000);

    c.bench_function("merkle_1000_txs", |b| {
        b.iter(|| {
            calculate_merkle_root(black_box(&txs))
        })
    });
}

criterion_group!(benches, benchmark_merkle);
criterion_main!(benches);
```

运行基准测试：

```bash
cargo bench --bench merkle_benchmark
```

---

## 调试技巧

### 日志调试

使用 `tracing` 和 `tracing-subscriber`:

```rust
use tracing::{info, debug, warn, error};

#[tokio::main]
async fn main() -> Result<()> {
    // 初始化日志
    tracing_subscriber::fmt()
        .with_max_level(tracing::Level::DEBUG)
        .init();

    info!("Starting blockchain node");

    let block = get_block().await;
    debug!("Received block: height={}", block.header.height);

    if block.transactions.is_empty() {
        warn!("Block has no transactions");
    }

    Ok(())
}
```

设置日志级别：

```bash
# 环境变量
RUST_LOG=debug cargo run
RUST_LOG=norn_core=trace cargo run

# 或在代码中
tracing_subscriber::fmt()
    .with_env_filter("norn_core=debug,norn_network=info")
    .init();
```

### LLDB 调试 (VSCode)

配置 `.vscode/launch.json`:

```json
{
  "version": "0.2.0",
  "configurations": [
    {
      "type": "lldb",
      "request": "launch",
      "name": "Debug norn",
      "cargo": {
        "args": [
          "build",
          "--bin=norn"
        ],
        "filter": {
          "name": "norn",
          "kind": "bin"
        }
      },
      "args": [],
      "cwd": "${workspaceFolder}"
    }
  ]
}
```

### GDB 调试 (命令行)

```bash
# 编译带调试符号
cargo build

# 启动 GDB
gdb target/debug/norn

# GDB 常用命令
(gdb) break main               # 设置断点
(gdb) run --config config.toml # 运行
(gdb) print variable           # 打印变量
(gdb) step                     # 单步执行
(gdb) continue                 # 继续执行
(gdb) backtrace               # 查看调用栈
```

### 性能分析

```bash
# 使用 flamegraph 生成火焰图
cargo install flamegraph
cargo flamegraph --bin norn

# 使用 perf (Linux)
perf record -g ./target/release/norn
perf report

# 使用 heaptrack 分析内存
heaptrack ./target/release/norn
heaptrack_print <pid>
```

---

## 贡献流程

### 1. 选择任务

查看 [GitHub Issues](https://github.com/your-org/rust-norn/issues)：

- `good first issue`: 适合新手
- `help wanted`: 需要帮助
- `enhancement`: 功能增强

### 2. 领取任务

在 issue 下评论：
```
I'd like to work on this issue
```

等待维护者分配。

### 3. 开发

```bash
# 创建分支
git checkout -b feature/issue-number-description

# 开发...
# 编写测试...
# 更新文档...

# 提交
git commit -m "feat: resolve #123: add feature description"
```

### 4. 创建 PR

标题格式：
```
[类型] 简短描述 (Fixes #123)
```

PR 描述模板：
```markdown
## 变更说明
<!-- 描述你做了什么 -->

## 变更类型
- [ ] Bug 修复
- [ ] 新功能
- [ ] 重构
- [ ] 文档更新

## 测试
- [ ] 添加了单元测试
- [ ] 添加了集成测试
- [ ] 所有测试通过

## 检查清单
- [ ] 代码符合项目规范
- [ ] 文档已更新
- [ ] 无 Clippy 警告
- [ ] Commit 信息清晰
```

### 5. 代码审查

- 等待维护者审查
- 根据反馈修改代码
- 所有 CI 检查通过
- 合并到主分支

---

## 常见问题

### 编译问题

**Q: protoc 找不到**
```bash
A: 安装 protobuf-compiler:
sudo apt install -y protobuf-compiler  # Ubuntu
brew install protobuf                   # macOS

# 设置 LIBCLANG_PATH (Windows)
set LIBCLANG_PATH=C:\Program Files\LLVM\bin
```

**Q: LLVM 相关错误**
```bash
A: 安装 LLVM:
sudo apt install -y llvm-dev libclang-dev  # Ubuntu
brew install llvm                           # macOS

# 或使用 rustfmt 替代
cargo fmt
```

**Q: 链接错误**
```bash
A: 清理构建缓存:
cargo clean
cargo build --release
```

### 运行时问题

**Q: 节点启动失败**
```bash
A: 检查配置文件:
- 端口是否被占用
- data_dir 是否有写权限
- node.key 是否存在

# 查看详细日志
RUST_LOG=debug ./target/release/norn --config config.toml
```

**Q: 数据库错误**
```bash
A: 删除并重建数据库:
rm -rf node_data/sled/
./target/release/norn --config config.toml
```

**Q: 网络连接失败**
```bash
A: 检查防火墙和网络:
- 确保端口开放 (4001, 50051)
- 检查 bootstrap_peers 配置
- 启用 mdns 进行本地发现
```

### 性能问题

**Q: TPS 很低**
```bash
A: 性能调优:
1. 增加区块 gas limit
2. 调整出块间隔
3. 使用 release 构建
4. 增加线程数
```

**Q: 内存占用高**
```bash
A: 内存优化:
1. 减小缓存大小
2. 启用状态剪裁
3. 定期清理历史数据
```

### 开发问题

**Q: 如何添加新的 RPC 方法？**
```rust
A: 1. 在 crates/rpc/src/protos/ 定义 protobuf
   2. 运行 cargo build 生成代码
   3. 在 crates/rpc/src/lib.rs 实现方法
   4. 添加对应测试
```

**Q: 如何修改共识机制？**
```rust
A: 主要文件在 crates/core/src/consensus/:
   - povf.rs: PoVF 实现
   - producer.rs: 区块生产者
   修改后需要更新验证逻辑
```

**Q: 如何添加新的交易类型？**
```rust
A: 1. 在 crates/common/src/types.rs 定义交易类型
   2. 在 validation.rs 添加验证逻辑
   3. 在 executor.rs 添加执行逻辑
   4. 更新 RPC 接口
```

---

## 相关资源

### 官方文档

- [Rust 语言](https://www.rust-lang.org/learn)
- [Tokio 运行时](https://tokio.rs/)
- [libp2p](https://docs.libp2p.io/)
- [revm (EVM)](https://github.com/bluealloy/revm)

### 社区

- [GitHub Issues](https://github.com/your-org/rust-norn/issues)
- [Discussions](https://github.com/your-org/rust-norn/discussions)
- [Discord 频道](https://discord.gg/rust-norn)

### 相关项目

- [go-norn](https://github.com/your-org/go-norn) - Go 参考实现
- [ethereum](https://github.com/ethereum/go-ethereum) - 以太坊 Go 实现

---

## 相关文档

- [架构文档](./架构文档.md)
- [API 文档](./API文档.md)
- [性能优化](./性能优化.md)
- [测试文档](./测试文档.md)
