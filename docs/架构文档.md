# 架构文档

**版本**: 1.0.0
**最后更新**: 2026-02-01

---

## 目录

- [系统概述](#系统概述)
- [架构设计原则](#架构设计原则)
- [核心组件](#核心组件)
- [数据流](#数据流)
- [模块依赖关系](#模块依赖关系)
- [共识机制](#共识机制)
- [状态管理](#状态管理)
- [网络协议](#网络协议)

---

## 系统概述

Norn 是一个高性能的区块链节点实现，采用 Rust 语言开发，使用创新的 PoVF (Proof of Verifiable Function) 共识机制。

### 设计目标

- **高性能**: 零成本抽象，接近 C/C++ 的性能
- **内存安全**: 编译时保证，无需 GC，无数据竞争
- **模块化**: 清晰的分层架构，易于扩展和维护
- **EVM 兼容**: 支持以太坊智能合约和工具

### 技术栈

| 组件 | 技术选型 |
|------|---------|
| **语言** | Rust (Edition 2021) |
| **异步运行时** | Tokio 1.36 |
| **P2P 网络** | libp2p 0.53 |
| **数据库** | SledDB 0.34 |
| **EVM** | revm v14 |
| **RPC** | Tonic 0.11 + jsonrpsee 0.20 |
| **密码学** | p256 (VRF) + k256 (ECDSA) |

---

## 架构设计原则

### 1. 分层架构

```
┌─────────────────────────────────────────┐
│            应用层 (API)                  │
│  gRPC / JSON-RPC / WebSocket            │
└─────────────────┬───────────────────────┘
                  │
┌─────────────────▼───────────────────────┐
│         编排层 (Orchestration)           │
│         norn-node / bin/norn            │
└─────────────────┬───────────────────────┘
                  │
┌─────────────────▼───────────────────────┐
│            业务层 (Business)              │
│  Core / Network / RPC / Crypto          │
└─────────────────┬───────────────────────┘
                  │
┌─────────────────▼───────────────────────┐
│          基础层 (Foundation)              │
│    Common / Storage / Consensus          │
└─────────────────────────────────────────┘
```

### 2. 模块化设计

每个 crate 职责单一，边界清晰：

- **norn-common**: 共享类型和工具
- **norn-crypto**: 密码学原语
- **norn-storage**: 持久化存储
- **norn-core**: 区块链核心逻辑
- **norn-network**: P2P 网络
- **norn-rpc**: API 接口
- **norn-node**: 节点编排

### 3. 异步优先

所有 I/O 操作使用 async/await 模式：
- 基于 Tokio 运行时
- 使用 `Arc<RwLock<T>>` 实现共享状态
- Channel 用于模块间通信

---

## 核心组件

### 1. 区块链引擎 (norn-core)

区块链核心负责状态管理和交易执行：

```
crates/core/src/
├── blockchain/      # 区块链主逻辑
├── consensus/       # 共识机制 (PoVF)
├── execution/       # 交易执行 (EVM)
├── state/          # 状态管理 (MPT + DB)
├── txpool.rs       # 交易池
├── validation.rs   # 区块和交易验证
└── block_buffer.rs # 区块缓冲区
```

#### 主要职责

- **BlockChain**: 维护区块链状态，管理区块添加和查询
- **Consensus**: PoVF 共识，包含 VRF 领导选举和 VDF 时间延迟
- **Executor**: EVM 交易执行，Gas 计费，状态转换
- **StateManager**: 管理账户状态、合约存储、状态根计算
- **TxPool**: 管理待处理交易，按 Gas 价格排序
- **Validation**: 验证区块签名、交易格式、状态转换

#### 数据结构

```rust
// 区块结构
pub struct Block {
    pub header: BlockHeader,
    pub transactions: Vec<Transaction>,
}

// 区块头
pub struct BlockHeader {
    pub timestamp: i64,
    pub prev_block_hash: Hash,
    pub block_hash: Hash,
    pub merkle_root: Hash,
    pub state_root: Hash,
    pub height: i64,
    pub public_key: PublicKey,
    pub params: Hash,        // VDF output
    pub gas_limit: u64,
    pub base_fee: u64,       // EIP-1559
}
```

### 2. 密码学模块 (norn-crypto)

提供核心密码学原语：

```
crates/crypto/src/
├── vrf.rs       # VRF (Verifiable Random Function)
├── vdf.rs       # VDF (Verifiable Delay Function)
├── transaction.rs # ECDSA 签名
└── hash.rs      # Keccak256 哈希
```

#### VRF (可验证随机函数)

- **算法**: P-256 EC-VRF
- **用途**: 随机领导者选举
- **流程**:
  1. 验证者使用私钥对选举数据生成证明
  2. 其他验证者验证证明有效性
  3. 根据输出值和权益权重选择领导者

```rust
pub struct VRFOutput {
    pub proof: Vec<u8>,
    pub value: Hash,
}

pub fn evaluate_vrf(
    secret_key: &SecretKey,
    message: &[u8],
) -> VRFOutput {
    // 生成 VRF 证明
}
```

#### VDF (可验证延迟函数)

- **算法**: 基于重复平方的时延计算
- **用途**: 防止提前知道领导者，防止长程攻击
- **流程**:
  1. 领导者计算 VDF(output = input^2^t mod N)
  2. 等待时间 t
  3. 发布输出和证明
  4. 验证者快速验证

```rust
pub struct VDFCalculator {
    pub iterations: u64,
}

impl VDFCalculator {
    pub fn calculate(&self, input: &Hash) -> Hash {
        // 顺序计算，无法并行化
    }

    pub fn verify(&self, input: &Hash, output: &Hash) -> bool {
        // 快速验证
    }
}
```

### 3. 网络层 (norn-network)

基于 libp2p 的 P2P 网络：

```
crates/network/src/
├── lib.rs        # 网络服务主入口
├── messages/     # P2P 消息定义
│   ├── mod.rs
│   ├── sync.rs   # 区块同步消息
│   └── compression.rs # 消息压缩
└── peer.rs       # 对等节点管理
```

#### 网络协议栈

```
┌─────────────────────────────────────┐
│         应用层协议                    │
│  Block Sync / Tx Gossip / Consensus  │
└─────────────────┬───────────────────┘
                  │
┌─────────────────▼───────────────────┐
│          libp2p                      │
│  ┌──────────┬──────────┬──────────┐ │
│  │ Gossipsub│ Kademlia │ mDNS     │ │
│  └──────────┴──────────┴──────────┘ │
└─────────────────┬───────────────────┘
                  │
┌─────────────────▼───────────────────┐
│          传输层                       │
│          TCP / WebSocket             │
└─────────────────────────────────────┘
```

#### 消息类型

```rust
pub enum NetworkMessage {
    /// 区块同步请求
    BlockRequest(BlockRequestMessage),
    /// 区块响应
    BlockResponse(BlockResponseMessage),
    /// 新区块广播
    NewBlock(Block),
    /// 交易广播
    NewTransaction(Transaction),
    /// VRF 输出分享
    VRFOutput(VRFOutputMessage),
}
```

#### 消息压缩

为了减少网络带宽，使用 zstd 压缩消息：

```rust
// 压缩格式: [0xFF, 0xCF, ALGORITHM, ...compressed_data]
pub const COMPRESSION_MAGIC: &[u8] = &[0xFF, 0xCF];

pub fn compress_message(msg: &[u8]) -> Vec<u8> {
    let compressed = zstd::encode_all(msg, 3);
    [COMPRESSION_MAGIC, &[0x01], &compressed].concat()
}
```

### 4. 存储层 (norn-storage)

基于 SledDB 的嵌入式 KV 存储：

```
crates/storage/src/
├── lib.rs        # 存储接口
├── sled.rs       # SledDB 实现
├── recovery.rs   # WAL 恢复
└── wal.rs        # Write-Ahead Log
```

#### 数据组织

```
data_dir/
├── sled/
│   ├── blocks         # 区块数据
│   ├── transactions   # 交易索引
│   ├── state          # 账户状态
│   ├── contracts      # 合约代码
│   └── metadata       # 元数据
├── node.key          # 节点密钥
└── wal/              # Write-Ahead Log
```

#### Key-Value 设计

| Key 前缀 | 数据类型 | Value |
|---------|---------|-------|
| `b` + height | Block | Block编码 |
| `t` + hash | Transaction | 交易数据 |
| `s` + address | State | 账户状态 |
| `c` + address | Code | 合约字节码 |
| `h` + height | Hash | 区块哈希 |

#### WAL (Write-Ahead Log)

```rust
pub enum WALEntry {
    Put { key: Vec<u8>, value: Vec<u8> },
    Delete { key: Vec<u8> },
}

// 写入流程:
// 1. 写入 WAL
// 2. 应用到 memtable
// 3. 定期刷盘到 SSTable
// 4. 清理旧 WAL
```

### 5. RPC 层 (norn-rpc)

提供双重 API 接口：

```
crates/rpc/src/
├── lib.rs          # RPC 服务入口
├── protos/         # gRPC protobuf 定义
├── ethereum.rs     # Ethereum JSON-RPC 实现
├── websocket.rs    # WebSocket 支持
└── mapper.rs       # 数据类型转换
```

#### gRPC API

基于 Protocol Buffers 定义：

```protobuf
service Blockchain {
    rpc GetBlockByNumber(BlockNumberRequest) returns (BlockResponse);
    rpc SendTransaction(TransactionRequest) returns (SendTransactionResponse);
    rpc GetBalance(BalanceRequest) returns (BalanceResponse);
}
```

#### Ethereum JSON-RPC

兼容以太坊标准接口：

```
eth_getBlockByNumber
eth_getBalance
eth_sendRawTransaction
eth_call
eth_estimateGas
eth_chainId
eth_blockNumber
...
```

---

## 数据流

### 交易提交流程

```
┌──────────┐
│  Client  │
└─────┬────┘
      │ 1. eth_sendRawTransaction
      ▼
┌──────────┐
│RPC Server│
└─────┬────┘
      │ 2. 解析并验证交易
      ▼
┌──────────┐
│ TxPool   │ ◄─────┐
└─────┬────┘       │
      │ 3. 添加到池 │
      ▼            │ 5. 从池取交易
┌──────────┐       │
│Blockchain│───────┘
└─────┬────┘
      │ 4. 广播到网络
      ▼
┌──────────┐
│ Network  │
└──────────┘
```

### 区块生成流程

```
┌──────────────┐
│ PoVF Consensus│
└──────┬───────┘
       │ 1. VRF 领导选举
       ▼
┌──────────────┐
│ VRF Producer │ ──► 生成 VRF 证明
└──────┬───────┘
       │ 2. VDF 时延计算
       ▼
┌──────────────┐
│ VDF Calculator│ ──► 计算时延函数
└──────┬───────┘
       │ 3. 收集交易
       ▼
┌──────────────┐
│  TxPool      │ ──► 按 Gas 价格排序
└──────┬───────┘
       │ 4. 执行交易
       ▼
┌──────────────┐
│   EVM        │ ──► 状态转换
└──────┬───────┘
       │ 5. 计算状态根
       ▼
┌──────────────┐
│ StateManager │ ──► MPT 计算
└──────┬───────┘
       │ 6. 打包区块
       ▼
┌──────────────┐
│ BlockBuffer  │ ──► 广播新区块
└──────────────┘
```

### 状态更新流程

```
┌──────────────┐
│  Executor    │
└──────┬───────┘
       │ 1. 执行交易，生成变更集
       ▼
┌──────────────┐
│CacheManager  │ ◄───┐
│ (Account +   │     │ 2. 查询状态
│  Storage)    │─────┘
└──────┬───────┘
       │ 3. 应用变更
       ▼
┌──────────────┐
│SyncStateManager│ ──► 更新缓存
└──────┬───────┘
       │ 4. 计算状态根
       ▼
┌──────────────┐
│ MerkleTree   │ ──► 构建 MPT
└──────┬───────┘
       │ 5. 持久化
       ▼
┌──────────────┐
│  StateDB     │ ──► 写入 SledDB
└──────────────┘
```

---

## 模块依赖关系

### Crate 依赖图

```
bin/norn
  │
  └──> norn-node
         │
         ├──> norn-core
         │      │
         │      ├──> norn-common
         │      ├──> norn-crypto
         │      ├──> norn-storage
         │      └──> norn-evm (revm)
         │
         ├──> norn-network
         │      │
         │      ├──> norn-common
         │      └──> norn-crypto
         │
         └──> norn-rpc
                │
                ├──> norn-common
                ├──> norn-core
                └──> norn-network
```

### 依赖规则

1. **单向依赖**: 上层依赖下层，下层不依赖上层
2. **Common 独立**: norn-common 不依赖任何业务 crate
3. **Core 聚合**: norn-core 聚合所有底层能力
4. **Node 编排**: norn-node 只负责组装和启动

---

## 共识机制

### PoVF (Proof of Verifiable Function)

PoVF 结合了 VRF 和 VDF 的优势：

#### VRF 阶段 - 随机领导者选举

```
1. 每个验证者对选举数据生成 VRF 证明
2. VRF 输出值作为随机种子
3. 根据输出值和权益权重计算得分
4. 得分最高的验证者成为候选领导者
```

#### VDF 阶段 - 时延保证

```
1. 候选领导者计算 VDF(output = input^2^t mod N)
2. 必须等待时间 t 完成计算
3. 发布 VDF 输出和证明
4. 其他验证者验证 VDF 输出
5. 验证通过后承认领导者
```

#### 优势

- **不可预测性**: VRF 确保领导者随机产生
- **公平性**: VDF 防止提前知道结果
- **可验证**: 所有步骤可公开验证
- **抗量子**: 基于椭圆曲线和数论问题

---

## 状态管理

### Merkle Patricia Tree (MPT)

Norn 使用 MPT 组织状态：

#### 树结构

```
                    Root Hash
                       │
              ┌────────┴────────┐
           Branch           Extension
         /  |  \  \            │
      Leaf ...              Branch
       │                    /  |  \
    Account              Leaf ... Leaf
```

#### 节点类型

1. **Leaf Node**: 键值对终端节点
   ```rust
   struct LeafNode {
       path: Vec<u8>,  // HP 编码的路径
       value: Vec<u8>, // RLP 编码的值
   }
   ```

2. **Extension Node**: 路径压缩节点
   ```rust
   struct ExtensionNode {
       path: Vec<u8>,      // HP 编码的公共前缀
       child_hash: Hash,   // 子节点哈希
   }
   ```

3. **Branch Node**: 16路分支节点
   ```rust
   struct BranchNode {
       children: [Option<Hash>; 16], // 16个子节点
       value: Option<Vec<u8>>,       // 可选的关联值
   }
   ```

### 状态缓存

三层缓存架构：

```
┌─────────────────────────────┐
│   L1: Account Cache         │  ← Moka (1000条)
└──────────┬──────────────────┘
           │ miss
┌──────────▼──────────────────┐
│   L2: Storage Cache         │  ← Moka (10000条)
└──────────┬──────────────────┘
           │ miss
┌──────────▼──────────────────┐
│   L3: StateDB (SledDB)      │  ← 持久化
└─────────────────────────────┘
```

### Async/Sync 桥接

由于 revm 是同步的，我们使用 SyncStateManager 桥接：

```rust
pub struct SyncStateManager {
    accounts: Arc<RwLock<AccountCache>>,
    storage: Arc<RwLock<StorageCache>>,
}

impl Database for SyncStateManager {
    fn get_account(&self, addr: &Address) -> Option<AccountInfo> {
        // 阻塞读取异步状态
        self.accounts.blocking_read().get(addr)
    }
}
```

---

## 网络协议

### 节点发现

1. **mDNS**: 局域网自动发现
2. **Kademlia DHT**: 全网节点发现
3. **Bootstrap Nodes**: 初始引导节点

### 消息传播

- **Gossipsub**: 订阅/发布模式
  - 新区块广播
  - 交易广播
  - VRF 输出分享

### 区块同步

#### Fast Sync 流程

```
1. 下载区块头 (轻量级)
2. 并行下载区块体
3. 验证检查点状态根
4. 批量写入数据库
```

#### Reorg 处理

```
┌─────────┐
│收到新区块│
└────┬────┘
     │ 检查链分叉
     ▼
┌─────────────┐
│找到共同祖先  │
└────┬────────┘
     │ 回滚到祖先
     ▼
┌─────────────┐
│应用新链     │
└─────────────┘
```

---

## 性能优化

### 关键优化点

1. **Moka 缓存**: 高性能并发缓存
2. **消息压缩**: zstd 压缩减少带宽
3. **批量写入**: 减少磁盘 I/O
4. **并行验证**: 多线程验证交易
5. **状态剪裁**: 定期清理历史状态

### 性能指标

| 指标 | 目标值 |
|------|-------|
| TPS | 1000+ |
| 出块间隔 | 1秒 |
| 交易确认时间 | ~2秒 |
| 内存占用 | ~200MB/节点 |
| 磁盘占用 | ~10GB/万区块 |

---

## 安全考虑

### 密码学安全

- **VRF**: P-256 曲线，256位安全级别
- **ECDSA**: secp256k1，与以太坊兼容
- **VDF**: 基于模幂运算的抗量子设计
- **哈希**: Keccak256 (SHA-3)

### 网络安全

- **TLS**: RPC 通信加密
- **节点认证**: 公钥身份验证
- **DDoS 防护**: 请求限流
- **Eclipse 攻击**: 多源节点发现

### 状态安全

- **WAL**: 防止数据丢失
- **DB 版本控制**: 防止版本冲突
- **快照**: 定期状态备份
- **默克尔证明**: 轻客户端验证

---

## 相关文档

- [API 文档](./API文档.md)
- [开发指南](./开发指南.md)
- [性能优化](./性能优化.md)
- [状态剪裁](./状态剪裁.md)
