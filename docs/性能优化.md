# 性能优化

**版本**: 1.0.0
**最后更新**: 2026-02-01

---

## 目录

- [概述](#概述)
- [性能指标](#性能指标)
- [缓存优化](#缓存优化)
- [网络优化](#网络优化)
- [存储优化](#存储优化)
- [共识优化](#共识优化)
- [EVM 执行优化](#evm-执行优化)
- [并发优化](#并发优化)
- [监控与分析](#监控与分析)
- [调优实战](#调优实战)

---

## 概述

Norn 区块链的性能优化贯穿整个架构设计，通过多层缓存、批量处理、并行执行等技术实现高性能。

### 性能目标

| 指标 | 基准 | 优化目标 |
|------|------|---------|
| **TPS** | ~500 | 1000+ |
| **出块延迟** | ~2s | <1s |
| **交易确认** | ~10s | ~2s |
| **内存占用** | ~500MB | <200MB |
| **启动时间** | ~5s | <2s |
| **同步速度** | ~100 blk/s | ~500 blk/s |

### 优化原则

1. **测量优先**: 先 profile，后优化
2. **热点聚焦**: 优化关键路径
3. **空间换时间**: 合理使用缓存
4. **并发利用**: 充分利用多核 CPU
5. **批量处理**: 减少系统调用

---

## 性能指标

### TPS (Transactions Per Second)

TPS 是衡量区块链吞吐量的核心指标。

```bash
# 运行 TPS 测试
./target/release/tps_test --rate 1000 --duration 60

# 输出示例:
# Target TPS: 1000
# Actual TPS: 856
# Success Rate: 85.6%
# Avg Latency: 234ms
```

### 延迟指标

| 指标 | 测量方法 | 目标 |
|------|---------|------|
| **交易池延迟** | 提交到入池时间 | <10ms |
| **执行延迟** | 交易执行时间 | <50ms |
| **区块确认延迟** | 打包到确认 | ~2s (2个区块) |
| **RPC 响应延迟** | API 调用时间 | <100ms |

### 资源占用

```bash
# 内存监控
ps aux | grep norn
# 或使用 pmap
pmap $(pgrep norn) | grep total

# CPU 监控
top -p $(pgrep norn)

# 磁盘 I/O 监控
iotop -p $(pgrep norn)

# 网络监控
ifstat -i eth0
```

---

## 缓存优化

### 三层缓存架构

```
┌─────────────────────────────────────────┐
│         L1: Hot Cache (Moka)            │
│  - 最新 1000 个区块                      │
│  - 最近 10000 个账户                     │
│  - 预取下一个区块                        │
└─────────────────┬───────────────────────┘
                  │ miss
┌─────────────────▼───────────────────────┐
│         L2: Warm Cache (Moka)           │
│  - 最近 10000 个区块                     │
│  - 最近 100000 个账户                    │
│  - 合约代码缓存                          │
└─────────────────┬───────────────────────┘
                  │ miss
┌─────────────────▼───────────────────────┐
│         L3: StateDB (SledDB)            │
│  - 持久化存储                            │
│  - 批量读写优化                          │
└─────────────────────────────────────────┘
```

### Moka 缓存配置

```rust
// crates/core/src/state/cache.rs

use moka::sync::Cache;

pub struct AccountCache {
    cache: Cache<Address, Account>,
}

impl AccountCache {
    pub fn new() -> Self {
        Cache::builder()
            .max_capacity(10_000)           // 最大缓存条目
            .time_to_live(Duration::from_secs(300))  // 5分钟过期
            .time_to_idle(Duration::from_secs(60))   // 1分钟未访问过期
            .build()
    }
}
```

### 缓存命中率监控

```rust
pub struct CacheMetrics {
    pub hits: AtomicU64,
    pub misses: AtomicU64,
}

impl CacheMetrics {
    pub fn hit_rate(&self) -> f64 {
        let hits = self.hits.load(Ordering::Relaxed);
        let total = hits + self.misses.load(Ordering::Relaxed);
        if total == 0 {
            0.0
        } else {
            hits as f64 / total as f64
        }
    }
}

// 目标命中率:
// - L1 Cache: >90%
// - L2 Cache: >80%
// - 总体: >95%
```

### 缓存预热

```rust
impl Blockchain {
    pub async fn warmup_cache(&self) -> Result<()> {
        let latest = self.get_latest_block().await?;
        let start_height = latest.header.height.saturating_sub(1000);

        // 预加载最近 1000 个区块
        for h in start_height..=latest.header.height {
            if let Some(block) = self.get_block_by_height(h).await {
                self.block_cache.insert(block.header.hash(), block);
            }
        }

        info!("Cache warmup completed");
        Ok(())
    }
}
```

---

## 网络优化

### 消息压缩

使用 zstd 压缩网络消息，减少带宽占用：

```rust
// crates/network/src/messages/compression.rs

use zstd;

const COMPRESSION_LEVEL: i32 = 3;  // 平衡压缩率和速度

pub fn compress_message(msg: &[u8]) -> Result<Vec<u8>> {
    let compressed = zstd::encode_all(msg, COMPRESSION_LEVEL)?;
    Ok(compressed)
}

// 压缩效果:
// - 区块消息: 50-70% 压缩率
// - 交易消息: 30-50% 压缩率
// - CPU 开销: <5%
```

### 批量消息传播

```rust
// 批量广播交易
pub async fn broadcast_transactions_batch(&self, txs: Vec<Transaction>) {
    const BATCH_SIZE: usize = 100;

    for chunk in txs.chunks(BATCH_SIZE) {
        let message = NetworkMessage::TransactionsBatch(chunk.to_vec());
        self.network.publish(message).await;
    }
}
```

### 连接池优化

```rust
// libp2p 连接配置
use libp2p::{swarm::NetworkBehaviour, tcp};

let tcp = tcp::Config::new()
    .nodelay(true)                    // 禁用 Nagle 算法
    .keep_alive_interval(Some(Duration::from_secs(10)));

// 连接限制
const MAX_CONNECTIONS: usize = 50;    // 最大连接数
const MAX_PENDING: usize = 10;        // 最大待连接数
```

### P2P 优化技巧

1. **选择性同步**: 只同步关键数据
2. **优先级队列**: 高优先级消息优先处理
3. **连接复用**: 复用已有连接
4. **本地发现**: mDNS 优先，减少外部请求

---

## 存储优化

### SledDB 配置优化

```rust
// crates/storage/src/sled.rs

use sled::Config;

pub fn open_db(path: &Path) -> Result<Db> {
    Config::new()
        .path(path)
        .cache_capacity(CacheCapacity::Bytes(256 * 1024 * 1024))  // 256MB
        .mode(sled::Mode::HighThroughput)                          // 高吞吐模式
        .use_compression(true)                                     // 启用压缩
        .flush_every_ms(Some(1000))                                // 每秒刷盘
        .print_profile_on_drop(false)                              // 关闭 profile
        .open()
}
```

### 批量写入

```rust
// 减少磁盘 I/O
impl StateDB {
    pub fn batch_write(&self, entries: Vec<(Vec<u8>, Vec<u8>)>) -> Result<()> {
        let mut batch = sled::Batch::default();

        for (key, value) in entries {
            batch.insert(key, value);
        }

        self.db.apply_batch(batch)?;
        Ok(())
    }
}
```

### 前台缓存策略

```rust
// 使用 MemTable 减少写入放大
pub struct WriteOptimizedDB {
    memtable: RwLock<BTreeMap<Vec<u8>, Vec<u8>>>,
    wal: WAL,
    db: Db,
    threshold: usize,  // MemTable 阈值
}

impl WriteOptimizedDB {
    pub async fn put(&self, key: Vec<u8>, value: Vec<u8>) -> Result<()> {
        // 1. 写入 WAL
        self.wal.write(&key, &value).await?;

        // 2. 写入 MemTable
        let mut table = self.memtable.write().await;
        table.insert(key.clone(), value);

        // 3. 达到阈值后刷盘
        if table.len() >= self.threshold {
            self.flush_to_disk().await?;
        }

        Ok(())
    }
}
```

### 状态剪裁

定期删除历史状态，减少存储占用：

```rust
// 剪裁策略:
// - 保留最近 10000 个区块的完整状态
// - 更早的区块只保留区块头
// - 每 1000 个区块执行一次剪裁

pub async fn prune_state(&self) -> Result<()> {
    let latest_height = self.get_latest_block().await?.header.height;
    let prune_below = latest_height.saturating_sub(10_000);

    for h in 0..=prune_below {
        if let Some(block) = self.get_block_by_height(h).await {
            // 删除状态，保留区块头
            self.db.remove_state(block.header.state_root)?;
            self.db.remove_transactions(&block.transactions)?;
        }
    }

    info!("State pruned below height {}", prune_below);
    Ok(())
}
```

---

## 共识优化

### VRF 预计算

```rust
// 提前计算多轮 VRF
pub struct VRFOptimizer {
    precomputed: VecDeque<(Hash, VRFOutput)>,
}

impl VRFOptimizer {
    pub async fn precompute(&mut self, rounds: usize) {
        for i in 0..rounds {
            let message = self.compute_future_message(i);
            let output = self.vrf.evaluate(&message);
            self.precomputed.push_back((message, output));
        }
    }

    pub fn get_next(&mut self) -> Option<VRFOutput> {
        self.precomputed.pop_front().map(|(_, output)| output)
    }
}
```

### VDF 并行验证

```rust
// 多线程验证 VDF 输出
use rayon::prelude::*;

pub fn verify_vdf_parallel(&self, outputs: Vec<VDFOutput>) -> Vec<bool> {
    outputs.par_iter()
        .map(|output| self.vdf.verify(&output))
        .collect()
}
```

### 领导者选举优化

```rust
// 使用 B-Tree 加速排序
pub struct LeaderElection {
    // 按得分排序的候选者
    candidates: BTreeMap<Score, Validator>,
}

impl LeaderElection {
    pub fn select_leader(&self) -> Option<&Validator> {
        // B-Tree 第一个元素就是最高分
        self.values().next()
    }
}
```

---

## EVM 执行优化

### 交易并行执行

```rust
// crates/core/src/execution/parallel.rs

use rayon::prelude::*;

pub fn execute_transactions_parallel(
    &self,
    txs: Vec<Transaction>,
) -> Result<Vec<Receipt>> {
    // 按非冲突分组（无读写依赖）
    let groups = self.group_non_conflicting(txs);

    // 并行执行每个组
    let receipts: Vec<_> = groups.par_iter()
        .map(|group| self.execute_group(group))
        .collect::<Result<Vec<_>>>()?
        .into_iter()
        .flatten()
        .collect();

    Ok(receipts)
}
```

### Gas 估算缓存

```rust
// 缓存 Gas 估算结果
pub struct GasEstimator {
    cache: Cache<Hash, u64>,  // tx_hash -> gas_used
}

impl GasEstimator {
    pub fn estimate(&self, tx: &Transaction) -> u64 {
        let hash = tx.hash();

        if let Some(&gas) = self.cache.get(&hash) {
            return gas;
        }

        // 执行并缓存
        let gas = self.estimate_internal(tx);
        self.cache.insert(hash, gas);
        gas
    }
}
```

### 合约字节码缓存

```rust
// 避免重复加载合约
pub struct CodeCache {
    cache: Cache<Hash, Vec<u8>>,
}

impl CodeCache {
    pub async fn get_code(&self, address: &Address) -> Result<Vec<u8>> {
        if let Some(code) = self.cache.get(address) {
            return Ok(code);
        }

        let code = self.db.get_code(address).await?;
        self.cache.insert(*address, code.clone());
        Ok(code)
    }
}
```

### 状态访问优化

```rust
// 批量读取账户状态
pub struct BatchReader {
    blockchain: Arc<Blockchain>,
}

impl BatchReader {
    pub async fn batch_get_accounts(&self, addrs: Vec<Address>) -> Vec<Option<Account>> {
        use futures::future::join_all;

        let futures: Vec<_> = addrs.into_iter()
            .map(|addr| self.blockchain.get_account(addr))
            .collect();

        join_all(futures).await
    }
}
```

---

## 并发优化

### 线程池配置

```rust
// crates/node/src/config.rs

use tokio::runtime::Builder;

pub fn create_runtime() -> Runtime {
    let cpus = num_cpus::get();

    Builder::new_multi_thread()
        .worker_threads(cpus)
        .max_blocking_threads(cpus * 2)
        .enable_all()
        .build()
        .unwrap()
}
```

### 读写锁优化

```rust
// 使用 RwLock 优化读多写少场景
pub struct Blockchain {
    // 读多写少：使用 RwLock
    latest_block: Arc<RwLock<Block>>,

    // 写频繁：使用 Mutex
    tx_pool: Arc<Mutex<TransactionPool>>,
}
```

### Channel 缓冲

```rust
// 使用有界 channel 防止内存溢出
let (tx, rx) = mpsc::channel(1000);  // 缓冲 1000 条消息

// 生产者
tokio::spawn(async move {
    for item in items {
        tx.send(item).await.unwrap();
    }
});

// 消费者
tokio::spawn(async move {
    while let Some(item) = rx.recv().await {
        process(item).await;
    }
});
```

### 任务调度优化

```rust
// 使用 spawn_blocking 处理阻塞操作
pub async fn process_blocking(&self) -> Result<()> {
    tokio::task::spawn_blocking(|| {
        // CPU 密集型操作
        self.heavy_computation()
    }).await?
}
```

---

## 监控与分析

### Prometheus 指标

```rust
// crates/node/src/metrics.rs

use prometheus::{Counter, Histogram, Gauge};

lazy_static! {
    static ref BLOCKS_PRODUCED: Counter = register_counter!(
        "norn_blocks_produced_total",
        "Total blocks produced"
    ).unwrap();

    static ref TX_EXECUTION_TIME: Histogram = register_histogram!(
        "norn_tx_execution_seconds",
        "Transaction execution time"
    ).unwrap();

    static ref MEMORY_USAGE: Gauge = register_gauge!(
        "norn_memory_usage_bytes",
        "Memory usage in bytes"
    ).unwrap();
}

// 使用
BLOCKS_PRODUCED.inc();
TX_EXECUTION_TIME.observe(duration.as_secs_f64());
MEMORY_USAGE.set(usage);
```

### 性能分析工具

```bash
# CPU Profiling (Flamegraph)
cargo install flamegraph
cargo flamegraph --bin norn

# Memory Profiling
cargo install heaptrack
heaptrack ./target/release/norn

# Instrumentation
cargo build --release
perf record -g ./target/release/norn
perf report

# Valgrind (内存泄漏检测)
valgrind --leak-check=full ./target/release/norn
```

### 日志分析

```rust
// 结构化日志
use tracing::{info_span, Instrument};

async fn handle_transaction(&self, tx: Transaction) -> Result<()> {
    let span = info_span!("handle_transaction",
        tx_hash = %tx.hash(),
        from = %tx.address,
        to = %tx.receiver
    );

    async move {
        info!("Processing transaction");
        // ...
    }.instrument(span).await
}
```

---

## 调优实战

### 场景 1: 提升 TPS

**问题**: TPS 只有 300，达不到目标 1000

**分析**:
```bash
# 运行 TPS 测试
./target/release/tps_test --rate 1000 --duration 60

# 使用 flamegraph 分析
cargo flamegraph --bin norn
```

**优化步骤**:

1. **增加交易池大小**:
```toml
# config.toml
[tx_pool]
max_size = 10000  # 增加到 10000
```

2. **启用并行执行**:
```rust
// crates/core/src/execution/mod.rs
pub async fn execute_transactions(&self, txs: Vec<Transaction>) -> Result<()> {
    if self.config.parallel_execution {
        self.execute_transactions_parallel(txs).await
    } else {
        self.execute_transactions_serial(txs).await
    }
}
```

3. **优化 Gas 计算**:
```rust
// 缓存 Gas 价格
lazy_static! {
    static ref GAS_PRICE_CACHE: Arc<RwLock<u64>> = Arc::new(RwLock::new(1_000_000_000));
}
```

**结果**: TPS 提升到 950+

### 场景 2: 降低内存占用

**问题**: 内存占用 800MB，目标 <200MB

**分析**:
```bash
# 查看内存使用
ps aux | grep norn
# 或
pmap $(pgrep norn) | grep total
```

**优化步骤**:

1. **减小缓存大小**:
```rust
// crates/core/src/state/cache.rs
Cache::builder()
    .max_capacity(1_000)  // 从 10_000 减少到 1_000
    .build()
```

2. **启用状态剪裁**:
```rust
// crates/node/src/service.rs
node.state_pruner.enable_pruning(
    KeepRecentBlocks(1000)  // 只保留最近 1000 个区块
).await?;
```

3. **优化 Vec 预分配**:
```rust
// 避免频繁 realloc
let mut transactions = Vec::with_capacity(100);
```

**结果**: 内存降到 180MB

### 场景 3: 加速区块同步

**问题**: 同步速度只有 50 blk/s

**优化步骤**:

1. **增加并发下载**:
```rust
// crates/node/src/syncer/fast_sync.rs
pub struct FastSyncConfig {
    pub max_parallel_downloads: usize,  // 从 10 增加到 50
}
```

2. **启用快照同步**:
```rust
// 从快照开始同步
let snapshot = self.download_latest_snapshot().await?;
self.apply_snapshot(snapshot).await?;
```

3. **优化批量大小**:
```rust
pub const BATCH_SIZE: usize = 500;  // 从 100 增加到 500
```

**结果**: 同步速度提升到 600 blk/s

---

## 性能检查清单

- [ ] 启用所有缓存 (L1/L2/L3)
- [ ] 配置合理的缓存大小
- [ ] 启用消息压缩
- [ ] 使用批量读写
- [ ] 优化数据库刷盘策略
- [ ] 启用并行交易执行
- [ ] 优化锁粒度
- [ ] 监控缓存命中率
- [ ] 定期执行状态剪裁
- [ ] 使用 release 构建
- [ ] 配置合理的线程池大小
- [ ] 启用 Prometheus 指标
- [ ] 定期进行性能分析

---

## 相关文档

- [架构文档](./架构文档.md)
- [开发指南](./开发指南.md)
- [API 文档](./API文档.md)
- [状态剪裁](./状态剪裁.md)
