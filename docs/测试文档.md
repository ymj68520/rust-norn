# 测试文档

**版本**: 1.0.0
**最后更新**: 2026-02-01

---

## 目录

- [概述](#概述)
- [单元测试](#单元测试)
- [集成测试](#集成测试)
- [性能测试](#性能测试)
- [TPS 测试](#tps-测试)
- [网络测试](#网络测试)
- [测试覆盖率](#测试覆盖率)
- [CI/CD](#cicd)

---

## 概述

Norn 项目采用多层次的测试策略，确保代码质量和系统稳定性。

### 测试层次

```
┌─────────────────────────────────────┐
│       E2E 测试 (端到端)               │
│  多节点网络、真实场景模拟              │
└─────────────────┬───────────────────┘
                  │
┌─────────────────▼───────────────────┐
│      集成测试 (Integration)          │
│  跨模块交互、API 接口、数据库          │
└─────────────────┬───────────────────┘
                  │
┌─────────────────▼───────────────────┐
│      单元测试 (Unit)                 │
│  函数、方法、结构体                   │
└─────────────────────────────────────┘
```

### 测试组织

```
tests/
├── unit/              # 单元测试（与源码同目录）
├── integration/       # 集成测试
├── benches/           # 性能测试
└── e2e/              # 端到端测试

test_integration/      # 跨 crate 集成测试
tps_test/             # TPS 性能测试
scalability_test/     # 可扩展性测试
db_test/              # 数据库测试
```

---

## 单元测试

### 编写单元测试

单元测试与源码放在同一文件中：

```rust
// crates/core/src/execution/executor.rs

#[cfg(test)]
mod tests {
    use super::*;
    use norn_common::types::Transaction;

    #[tokio::test]
    async fn test_execute_transfer() {
        // 准备测试环境
        let executor = Executor::new(test_config());
        let mut state = TestStateManager::new();

        // 创建测试交易
        let tx = Transaction {
            value: U256::from(1000),
            ..Default::default()
        };

        // 执行交易
        let receipt = executor.execute_transaction(&tx, &mut state).await.unwrap();

        // 验证结果
        assert_eq!(receipt.status, true);
        assert_eq!(receipt.gas_used, 21000);
    }

    #[test]
    fn test_gas_calculation() {
        let gas = calculate_gas(100, 50);
        assert_eq!(gas, 21000);
    }
}
```

### 运行单元测试

```bash
# 运行所有单元测试
cargo test --workspace --lib

# 运行特定 crate 的测试
cargo test -p norn-core --lib

# 运行特定测试函数
cargo test test_execute_transfer

# 显示输出
cargo test -- --nocapture

# 运行并显示标准输出和错误
cargo test -- --show-output
```

### 测试辅助工具

```rust
// crates/common/src/testing.rs

use norn_common::types::*;

pub mod test_utils {
    /// 创建测试账户
    pub fn create_test_account() -> Account {
        Account {
            balance: U256::from(1_000_000_000_000_000_000u128), // 1 ETH
            nonce: 0,
            code_hash: Hash::default(),
            storage_root: Hash::default(),
        }
    }

    /// 创建测试交易
    pub fn create_test_transaction() -> Transaction {
        Transaction {
            hash: Hash::random(),
            address: Address::random(),
            receiver: Address::random(),
            gas: 21000,
            nonce: 0,
            data: Vec::new(),
            value: U256::from(1000),
            timestamp: chrono::Utc::now().timestamp(),
            signature: Vec::new(),
            tx_type: 0,
            chain_id: 31337,
            ..Default::default()
        }
    }

    /// 创建测试区块
    pub fn create_test_block(height: i64) -> Block {
        Block {
            header: BlockHeader {
                height,
                timestamp: chrono::Utc::now().timestamp(),
                ..Default::default()
            },
            transactions: vec![],
        }
    }
}
```

---

## 集成测试

### 集成测试位置

集成测试放在 `test_integration/` 目录：

```
test_integration/
├── blockchain_test.rs      # 区块链集成测试
├── consensus_test.rs       # 共识集成测试
├── network_test.rs         # 网络集成测试
├── rpc_test.rs            # RPC 集成测试
└── mod.rs                 # 测试模块入口
```

### 编写集成测试

```rust
// test_integration/blockchain_test.rs

use norn_core::blockchain::Blockchain;
use norn_common::types::{Block, Transaction};
use norn_storage::StateDB;

#[tokio::test]
async fn test_full_block_flow() {
    // 1. 初始化环境
    let temp_dir = tempfile::tempdir().unwrap();
    let db = Arc::new(StateDB::new(temp_dir.path()).await.unwrap());
    let blockchain = Blockchain::new(db.clone(), test_config()).await;

    // 2. 创建并添加区块
    let block = create_test_block(1);
    blockchain.add_block(block.clone()).await;

    // 3. 验证区块已添加
    let retrieved = blockchain.get_block_by_height(1).await;
    assert!(retrieved.is_some());
    assert_eq!(retrieved.unwrap().hash(), block.hash());

    // 4. 验证最新区块
    let latest = blockchain.get_latest_block().await;
    assert_eq!(latest.header.height, 1);
}

#[tokio::test]
async fn test_transaction_execution() {
    // 1. 设置区块链
    let blockchain = setup_test_blockchain().await;

    // 2. 创建交易
    let tx = create_test_transaction();

    // 3. 发送交易到交易池
    blockchain.send_transaction(tx.clone()).await.unwrap();

    // 4. 等待交易被打包
    tokio::time::sleep(Duration::from_secs(2)).await;

    // 5. 验证交易已执行
    let receipt = blockchain.get_transaction_receipt(tx.hash()).await;
    assert!(receipt.is_some());
    assert_eq!(receipt.unwrap().status, true);
}

// 辅助函数
async fn setup_test_blockchain() -> Arc<Blockchain> {
    let temp_dir = tempfile::tempdir().unwrap();
    let db = Arc::new(StateDB::new(temp_dir.path()).await.unwrap());
    Arc::new(Blockchain::new(db, test_config()).await)
}

fn test_config() -> BlockchainConfig {
    BlockchainConfig {
        block_interval: 1,
        ..Default::default()
    }
}
```

### 运行集成测试

```bash
# 运行所有集成测试
cargo test --test integration

# 运行特定集成测试
cargo test --test blockchain_test

# 只运行集成测试（跳过单元测试）
cargo test --test '*'
```

### 数据库测试

```rust
// db_test/src/lib.rs

use norn_storage::StateDB;
use norn_common::types::Hash;

#[tokio::test]
async fn test_database_operations() {
    let temp_dir = tempfile::tempdir().unwrap();
    let db = StateDB::new(temp_dir.path()).await.unwrap();

    // 测试写入
    let key = b"test_key";
    let value = b"test_value";
    db.put(key.to_vec(), value.to_vec()).await.unwrap();

    // 测试读取
    let retrieved = db.get(key).await.unwrap();
    assert_eq!(retrieved, Some(value.to_vec()));

    // 测试删除
    db.delete(key).await.unwrap();
    let deleted = db.get(key).await.unwrap();
    assert_eq!(deleted, None);
}

#[tokio::test]
async fn test_concurrent_access() {
    let db = Arc::new(StateDB::new(temp_path()).await.unwrap());
    let mut handles = vec![];

    // 并发写入
    for i in 0..100 {
        let db_clone = db.clone();
        let handle = tokio::spawn(async move {
            let key = format!("key_{}", i);
            let value = format!("value_{}", i);
            db_clone.put(key.into_bytes(), value.into_bytes()).await
        });
        handles.push(handle);
    }

    // 等待所有写入完成
    for handle in handles {
        handle.await.unwrap().unwrap();
    }

    // 验证所有数据
    for i in 0..100 {
        let key = format!("key_{}", i);
        let value = db.get(key.as_bytes()).await.unwrap();
        assert!(value.is_some());
    }
}
```

---

## 性能测试

### Criterion 基准测试

```rust
// benches/merkle_bench.rs

use criterion::{black_box, criterion_group, criterion_main, Criterion, BenchmarkId};
use norn_core::state::merkle::MerkleTree;

fn bench_merkle_root(c: &mut Criterion) {
    let mut group = c.benchmark_group("merkle_root");

    for tx_count in [10, 100, 1000, 10000].iter() {
        group.bench_with_input(
            BenchmarkId::from_parameter(tx_count),
            tx_count,
            |b, &tx_count| {
                let txs = create_test_transactions(tx_count);

                b.iter(|| {
                    calculate_merkle_root(black_box(&txs))
                });
            },
        );
    }

    group.finish();
}

fn bench_state_update(c: &mut Criterion) {
    let db = setup_test_db().await;

    c.bench_function("state_update_100_accounts", |b| {
        let accounts = create_test_accounts(100);

        b.iter(|| {
            for account in &accounts {
                db.update_account(account).unwrap();
            }
        });
    });
}

criterion_group!(benches, bench_merkle_root, bench_state_update);
criterion_main!(benches);
```

### 运行性能测试

```bash
# 运行所有基准测试
cargo bench

# 运行特定基准测试
cargo bench --bench merkle_bench

# 生成火焰图
cargo bench --bench merkle_bench -- --save-baseline main

# 比较性能变化
cargo bench --bench merkle_bench -- --baseline main
```

### 可扩展性测试

```rust
// scalability_test/src/lib.rs

use norn_core::blockchain::Blockchain;

#[tokio::test]
async fn test_blockchain_scalability() {
    let blockchain = setup_test_blockchain().await;

    let start = std::time::Instant::now();

    // 添加 10000 个区块
    for i in 1..=10000 {
        let block = create_test_block(i);
        blockchain.add_block(block).await;

        if i % 1000 == 0 {
            let elapsed = start.elapsed();
            let tps = (i as f64) / elapsed.as_secs_f64();
            println!("{} blocks: {:.2} blocks/s", i, tps);
        }
    }

    let elapsed = start.elapsed();
    println!("Total: {:.2}s, {:.2} blocks/s",
        elapsed.as_secs_f64(),
        10000.0 / elapsed.as_secs_f64()
    );
}

#[tokio::test]
async fn test_transaction_pool_scalability() {
    let mut tx_pool = TransactionPool::new(10000);

    let start = std::time::Instant::now();

    // 添加 100000 个交易
    for _ in 0..100000 {
        let tx = create_test_transaction();
        tx_pool.add_transaction(tx).unwrap();
    }

    let elapsed = start.elapsed();
    println!("Added 100000 transactions in {:.2}ms",
        elapsed.as_millis()
    );

    // 测试查询性能
    let start = std::time::Instant::now();
    let txs = tx_pool.get_transactions(1000);
    let elapsed = start.elapsed();

    println!("Retrieved {} transactions in {:.2}μs",
        txs.len(),
        elapsed.as_micros()
    );
}
```

---

## TPS 测试

### TPS 测试工具

```bash
# 构建 TPS 测试工具
cargo build -p tps_test --release

# 运行默认测试（100 TPS, 60秒）
./target/release/tps_test

# 自定义参数
./target/release/tps_test \
  --rate 500 \
  --duration 120 \
  --rpc-address 127.0.0.1:50051 \
  --batch-size 50

# 输出示例:
# Target TPS: 500
# Duration: 120s
# Total sent: 60000
# Total confirmed: 52340
# Actual TPS: 436.17
# Success rate: 87.23%
```

### TPS 测试实现

```rust
// tps_test/src/main.rs

use reqwest::Client;
use tokio::time::{interval, Duration};

#[tokio::main]
async fn main() -> Result<()> {
    let args = Args::parse();

    println!("TPS Test Configuration:");
    println!("  Rate: {} TPS", args.rate);
    println!("  Duration: {}s", args.duration);

    let http_client = Client::new();
    let start_time = std::time::Instant::now();
    let mut confirmed_count = 0u64;
    let mut sent_count = 0u64;

    // 创建交易发送器
    let mut sender = tokio::time::interval(Duration::from_millis(1000 / args.rate));

    // 创建监控任务
    let monitor_task = tokio::spawn(async move {
        let mut interval = tokio::time::interval(Duration::from_secs(5));
        loop {
            interval.tick().await;
            let elapsed = start_time.elapsed().as_secs();
            let actual_tps = confirmed_count as f64 / elapsed as f64;
            println!("[{}] Sent: {}, Confirmed: {}, TPS: {:.2}",
                elapsed, sent_count, confirmed_count, actual_tps
            );
        }
    });

    // 发送交易
    while start_time.elapsed() < Duration::from_secs(args.duration) {
        sender.tick().await;

        let tx = create_test_transaction();
        match send_transaction(&http_client, &tx).await {
            Ok(hash) => {
                sent_count += 1;

                // 等待确认
                if wait_for_confirmation(&http_client, &hash).await {
                    confirmed_count += 1;
                }
            }
            Err(e) => eprintln!("Send failed: {}", e),
        }
    }

    monitor_task.abort();

    // 输出统计
    let elapsed = start_time.elapsed().as_secs_f64();
    let actual_tps = confirmed_count as f64 / elapsed;
    let success_rate = (confirmed_count as f64 / sent_count as f64) * 100.0;

    println!("\n=== Test Results ===");
    println!("Total sent: {}", sent_count);
    println!("Total confirmed: {}", confirmed_count);
    println!("Actual TPS: {:.2}", actual_tps);
    println!("Success rate: {:.2}%", success_rate);

    Ok(())
}
```

---

## 网络测试

### 多节点测试脚本

```bash
#!/bin/bash
# tests/multi_node_test.sh

set -e

echo "=== Multi-Node Network Test ==="

# 启动 3 个节点
./target/release/norn --config node1_config.toml &
NODE1_PID=$!

./target/release/norn --config node2_config.toml &
NODE2_PID=$!

./target/release/norn --config node3_config.toml &
NODE3_PID=$!

echo "Nodes started, waiting for discovery..."
sleep 10

# 检查节点连接
echo "Checking peer connections..."
PEER1=$(curl -s http://localhost:50051/peers | jq '.peers | length')
PEER2=$(curl -s http://localhost:50052/peers | jq '.peers | length')
PEER3=$(curl -s http://localhost:50053/peers | jq '.peers | length')

echo "Node1 peers: $PEER1"
echo "Node2 peers: $PEER2"
echo "Node3 peers: $PEER3"

# 发送测试交易
echo "Sending test transactions..."
for i in {1..100}; do
  curl -X POST http://localhost:50051/send_transaction \
    -H "Content-Type: application/json" \
    -d "{\"value\": \"1000\"}"
  sleep 0.1
done

# 等待共识
echo "Waiting for consensus..."
sleep 10

# 检查所有节点的区块高度
HEIGHT1=$(curl -s http://localhost:50051/block_number)
HEIGHT2=$(curl -s http://localhost:50052/block_number)
HEIGHT3=$(curl -s http://localhost:50053/block_number)

echo "Node1 height: $HEIGHT1"
echo "Node2 height: $HEIGHT2"
echo "Node3 height: $HEIGHT3"

# 验证一致性
if [ "$HEIGHT1" == "$HEIGHT2" ] && [ "$HEIGHT2" == "$HEIGHT3" ]; then
  echo "✓ All nodes have consistent height"
else
  echo "✗ Nodes have inconsistent heights!"
  exit 1
fi

# 清理
kill $NODE1_PID $NODE2_PID $NODE3_PID

echo "=== Test Passed ==="
```

### 网络分区测试

```rust
// test_integration/partition_test.rs

#[tokio::test]
async fn test_network_partition_recovery() {
    // 启动 3 个节点
    let node1 = start_test_node(4001).await;
    let node2 = start_test_node(4002).await;
    let node3 = start_test_node(4003).await;

    // 等待网络稳定
    tokio::time::sleep(Duration::from_secs(5)).await;

    // 获取分区前高度
    let height_before = node1.get_block_number().await;

    // 模拟网络分区：断开 node2 和 node3
    node2.disconnect_peer(node3.id()).await;

    // 在两边分别发送交易
    node1.send_test_transaction().await;
    node2.send_test_transaction().await;

    // 等待出块
    tokio::time::sleep(Duration::from_secs(5)).await;

    // 恢复连接
    node2.connect_peer(node3.id()).await;

    // 等待共识恢复
    tokio::time::sleep(Duration::from_secs(10)).await;

    // 验证所有节点达到一致状态
    let h1 = node1.get_block_number().await;
    let h2 = node2.get_block_number().await;
    let h3 = node3.get_block_number().await;

    assert_eq!(h1, h2);
    assert_eq!(h2, h3);
    assert!(h1 > height_before);
}
```

---

## 测试覆盖率

### 安装覆盖率工具

```bash
# 安装 tarpaulin
cargo install cargo-tarpaulin

# 或使用 grcov
cargo install grcov
```

### 生成覆盖率报告

```bash
# 使用 tarpaulin
cargo tarpaulin --workspace --out Html --output-dir coverage/

# 使用 grcov
cargo clean
CARGO_INCREMENTAL=0 RUSTFLAGS="-Zinstrument-coverage" \
  cargo build --workspace
RUSTFLAGS="-Zinstrument-coverage" \
  cargo test --workspace
grcov ./target/debug \
  --binary-path ./target/debug \
  -s . \
  -t html \
  --branch \
  --ignore-not-existing \
  --output-dir ./coverage/
```

### 查看覆盖率

```bash
# 打开 HTML 报告
firefox coverage/index.html

# 或在终端查看
cargo tarpaulin --workspace --out Stdout
```

### 覆盖率目标

| 组件 | 目标覆盖率 |
|------|-----------|
| 核心逻辑 | >90% |
| 密码学 | 100% |
| 状态管理 | >85% |
| 网络层 | >80% |
| RPC | >75% |

---

## CI/CD

### GitHub Actions 配置

```yaml
# .github/workflows/ci.yml

name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3

    - name: Install Rust
      uses: actions-rs/toolchain@v1
      with:
        profile: minimal
        toolchain: stable
        components: rustfmt, clippy
        override: true

    - name: Install dependencies
      run: |
        sudo apt update
        sudo apt install -y protobuf-compiler

    - name: Format check
      run: cargo fmt --all -- --check

    - name: Clippy
      run: cargo clippy --workspace --all-targets --all-features -- -D warnings

    - name: Run tests
      run: cargo test --workspace --all-features

    - name: Coverage
      run: |
        cargo install cargo-tarpaulin
        cargo tarpaulin --workspace --out Xml --output-dir coverage/

    - name: Upload to codecov.io
      uses: codecov/codecov-action@v3
      with:
        files: ./coverage/cobertura.xml

  lint:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3

    - name: Install Rust
      uses: actions-rs/toolchain@v1
      with:
        toolchain: stable

    - name: Run lints
      run: cargo clippy --workspace -- -D warnings

  build:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3

    - name: Install Rust
      uses: actions-rs/toolchain@v1
      with:
        toolchain: stable

    - name: Build release
      run: cargo build --workspace --release

    - name: Upload binary
      uses: actions/upload-artifact@v3
      with:
        name: norn-release
        path: target/release/norn
```

### 本地 CI 测试

```bash
# 运行完整 CI 流程
make ci

# 或手动执行
cargo fmt --all -- --check
cargo clippy --workspace --all-targets --all-features -- -D warnings
cargo test --workspace --all-features
cargo build --workspace --release
```

---

## 测试最佳实践

### 1. 测试命名

```rust
// ✓ 好的命名
#[test]
fn test_transfer_with_insufficient_balance_fails() {
}

// ✗ 不好的命名
#[test]
fn test_transfer() {
}
```

### 2. 测试隔离

```rust
// 每个测试使用独立的临时目录
#[tokio::test]
async fn test_something() {
    let temp_dir = tempfile::tempdir().unwrap();
    let db = StateDB::new(temp_dir.path()).await.unwrap();

    // 测试逻辑...
    // temp_dir 会在 drop 时自动清理
}
```

### 3. 异步测试

```rust
// 使用 tokio::test
#[tokio::test]
async fn test_async_operation() {
    let result = async_function().await;
    assert!(result.is_ok());
}

// 设置超时
#[tokio::test]
async fn test_with_timeout() {
    tokio::time::timeout(
        Duration::from_secs(5),
        long_running_operation()
    ).await.unwrap();
}
```

### 4. Mock 外部依赖

```rust
// 使用 mockito 测试 HTTP API
#[tokio::test]
async fn test_rpc_client() {
    let mut server = mockito::Server::new();

    let mock = server.mock("POST", "/")
        .with_status(200)
        .with_body(r#"{"jsonrpc":"2.0","result":"0x1","id":1}"#)
        .create();

    let client = RpcClient::new(server.url());
    let result = client.get_block_number().await.unwrap();

    mock.assert();
    assert_eq!(result, 1);
}
```

---

## 常见问题

### Q1: 测试运行很慢怎么办？

A: 使用 `--release` 模式运行测试，或者使用 `cargo test --release`。注意这会增加编译时间。

### Q2: 如何测试并发问题？

A: 使用 `tokio::spawn` 创建多个并发任务，或使用 `rayon` 进行并行测试。

### Q3: 如何调试失败的测试？

A: 使用 `cargo test -- --nocapture --show-output` 查看输出，或使用 `cargo test -- --exact test_name` 运行单个测试。

---

## 相关文档

- [架构文档](./架构文档.md)
- [开发指南](./开发指南.md)
- [API 文档](./API文档.md)
- [性能优化](./性能优化.md)
